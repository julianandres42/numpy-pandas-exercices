# -*- coding: utf-8 -*-
"""Numpy_Excercises_Session_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/191mM7RK4ndjvwzJoiKESHDVSw_6VkCm8
"""

import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

"""# Numpy Excercises - Session 1

## Creating arrays.
### Exercise 1 
Create an int array from the list [2.4, 5, 7.8, 25]
"""

list_1 = [2.4, 5, 7.8, 25]
array_1 =  np.asarray(list_1,dtype=int)
array_1

"""### Exercise 2  
Create an float array from the list [-2, 3, 4, 7, 1, 9]
"""

list_2 = [-2, 3, 4, 7, 1, 9]
array_2 = np.asarray(list_2,dtype=float)
array_2

"""### Exercise 3. 
Create a length-30 integer array filled with zeros.
"""

array_3 = np.zeros(30)
array_3

"""### Exercise 4. 

Create a 7x5 floating-point array filled with 1s.
"""

array_4 = np.ones((7,5),dtype=float)
array_4

"""### Exercise 5.

Create a 16x16 array filled with 3.14
"""

array_5 = np.full((16,16),3.14) 
array_5

"""### Exercise 6.

Create an array filled with a linear sequence starting at 0, ending at 90, stepping by 3
"""

array_6 = np.arange(0,90,3)

"""### Exercise 7.

Create an array of 10 values evenly spaced between 0 and 3
"""

array_7 = np.linspace(0,3,num=10)
array_7

"""### Exercise 8.

Create a 5x5 array of random integers in the interval [0, 10)
"""

array_8 =  np.random.randint(10, size=(5, 5))
array_8

"""# Nueva secci√≥n

## Python lists vs Numpy arrays.

### Exercise 9.  

Calculating procesing time for python list creation 



```
* Create a python list with numbers from 0 to 6 millions steping by 500.000 and stored in a list called `steps`.
* Iterate over the `steps`.
* For each iteration, create a python list of 6 million elements with numbers betweent 1 and 10 and calculate how many seconds it took to create that list.
* Add the calculated time to a python list called `op_time_list`
* Print first 10 elements from `op_time_list`
```
"""

# Write your code here.
import random
from datetime import datetime
op_time_list = []
op_time_numpy = []

Start = 1
Stop = 10
limit = 6000000

steps = range(1,6000000,500000)
for item in steps:
  now1 = datetime.now()
  internalList = [random.randint(Start, Stop) for iter in range(limit)]
  now2 = datetime.now()
  timeDelta = now1 - now2
  total_seconds = timeDelta.total_seconds()
  op_time_list.append(total_seconds)

for item in steps:
  now1 = datetime.now()
  internalList = np.random.randint(1,10, size=6000000)
  now2 = datetime.now()
  timeDelta = now1 - now2
  total_seconds = timeDelta.total_seconds()
  op_time_numpy.append(total_seconds)


#print()

"""### Exercise 10.

Calculating procesing time for numpy array creation
        

```
* Iterate over the `steps`.
* For each iteration, create a numpy array of 6 million elements with numbers betweent 1 and 10 and calculate how many seconds it took to create that array.
* Add the calculated time to a python list called `op_time_numpy`
* Print first 10 elements from `op_time_numpy`
```

### Exercise 11.

Compare `op_time_list` with `op_time_numpy`
"""

# No code required here.
# Just run this cell :).

fig = plt.figure(figsize=(15, 5))
plt.plot(steps, op_time_list, '-b', label='Python lists')
plt.plot(steps, op_time_numpy, '--g', label='Numpy arrays')

plt.legend();

"""## Challenge: Slicing Image layers.

**Extract RGB layers from an image.**
"""

!wget -q https://raw.githubusercontent.com/mrugeles/numpy-pandas-exercices/master/640px-Bucephala-albeola-010.jpg
im = np.array(Image.open('640px-Bucephala-albeola-010.jpg'))
im.shape

def plot_image_channel(shape, channel, img_channel):
  temp = np.zeros(shape, dtype='uint8')
  temp[:, :, channel] = img_channel
  plt.imshow(temp);

red_channel = im[:,:,0]
plot_image_channel(im.shape, 0, red_channel)

green_channel = im[:,:,1]
plot_image_channel(im.shape, 1, green_channel)

blue_channel = im[:,:,2]
plot_image_channel(im.shape, 2, blue_channel)

m = np.random.randint(1, 10, 36).reshape(6, 6)
m

def smooth(img):
    avg_img =(    
                  img[1:-1 ,1:-1]  # center
                + img[0:-2 ,0:-2]  # top left
                + img[ :-2 ,1:-1]  # top
                + img[0:-2 ,2:  ]  # top right
                + img[2:   ,0:-2]  # bottom left
                + img[2:   ,1:-1]  # bottom
                + img[2:   ,2:  ]  # bottom right
                + img[1:-1 , :-2]  # left
                + img[1:-1 ,2:  ]  # right
                ) / 9
    return avg_img

smooth(m).shape

im[:, :, 2].shape

smooth(im[:, :, 2])